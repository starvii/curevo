import re
import os
import string
import collections


def hump_to_underline(hump):
    """
    将驼峰命名方式转为下划线命名方式
    :param hump: string
    :return: underline
    """
    temp = collections.deque()
    temp.append(hump[0].lower())
    for c in hump[1:]:
        if c in string.ascii_lowercase:
            temp.append(c)
        elif c in string.ascii_uppercase:
            temp.append('_')
            temp.append(c.lower())
    return ''.join(temp)


def underline_to_hump(underline):
    """
    将下划线命名方式转为驼峰命名方式（首字母大写）
    :param underline: string
    :return: hump
    """
    temp = collections.deque()
    temp.append(underline[0].upper())
    nxt = False
    for c in underline[1:]:
        if nxt:
            temp.append(c.upper())
            nxt = False
            continue
        if c == '_':
            nxt = True
        else:
            temp.append(c)
    return ''.join(temp)


def find_by_tags(text, tag, prefix='(', suffix=')'):
    """
    用于处理括号嵌套的情况
    :param text: 需要处理的文字
    :param tag: 方法名，如 Table, Column 等
    :param prefix: 一般为左括号 （
    :param suffix: 一般为右括号 ）
    :return: target, start, end
    """
    stack = collections.deque()
    t = tag + prefix
    start = text.find(t)
    if start > 0:
        idx = start + len(t)
        stack.append(idx)
        while len(stack) > 0:
            idx += 1
            c = text[idx]
            if c == prefix:
                stack.append(idx)
            elif c == suffix:
                stack.pop()
        end = idx
        return text[start:end + 1], start, end
    else:
        return None, 0, len(text) - 1


class TableMeta(object):

    def __init__(self):
        self.table_name = ''
        self.entity_name = ''
        self.columns = collections.OrderedDict()


def linesep(text):
    """
    获取换行符
    :param text:
    :return:
    """
    if '\r\n' in text:
        return '\r\n'  # Windows
    elif '\r' in text:
        return '\r'  # MAC
    elif '\n' in text:
        return '\n'  # Linux
    else:
        return None  # maybe only one line.


def del_python_line_contact(text):
    """
    替换python代码中的换行符\
    方便后续内容识别
    :param text:
    :return:
    """
    sep = linesep(text)
    lines = text.split(sep)
    temp = collections.deque()
    line_temp = collections.deque()
    for l in lines:
        if len(l.strip()) > 0:
            l = l.rstrip()
            if l[-1] == '\\':
                line_temp.append(l[:-1])
            else:
                line_temp.append(l)
                temp.append(''.join(line_temp))
                line_temp = collections.deque()
    return sep.join(temp)


def split_table(text):
    """
    从文本（python代码）中获取table相关的行
    :param text:
    :return: list(table_text)
    """
    tables = collections.deque()
    t = text
    while True:
        r = find_by_tags(t, 'Table')
        if r[0]:
            tables.append(r[0])
            t = t[r[2] + 1:]
        else:
            break
    return tables


def create_table_meta(table_text):
    tm = TableMeta()
    t = table_text.replace('Table(', '')
    t = t[:-1]
    tm.table_name = t.split(',')[0][1:-1]
    tm.entity_name = underline_to_hump(tm.table_name)
    columns = collections.deque()
    while True:
        r = find_by_tags(t, 'Column')
        if r[0]:
            columns.append(r[0])
            t = t[r[2] + 1:]
        else:
            break
    for c in columns:
        t = c.replace('Column(', '')
        t = t[:-1]
        field_name = t.split(',')[0][1:-1]
        property_name = underline_to_hump(field_name)
        tm.columns[property_name] = c
    return tm


def create_entity_text(table_meta):
    entity_line = 'class {}(Base):\n'.format(table_meta.entity_name)
    table_line = "    __tablename__ = '{}'\n".format(table_meta.table_name)
    fields = collections.deque()
    for f, v in table_meta.columns.items():
        line = '    {} = {}'.format(f, v)
        fields.append(line)
    return entity_line + table_line + '\n'.join(fields)


def create_header(table_file_content):
    sep = linesep(table_file_content)
    lines = table_file_content.split(sep)
    header = collections.deque()
    header.append('# generate by make_entity.py')
    header.append('# please do NOT edit this file directly.')
    header.append('# edit table.py and regenerate it.' + sep)
    for line in lines:
        line = line.strip()
        if 'import ' in line and 'sqlalchemy' in line:
            header.append(line)
    header.append('from sqlalchemy.ext.declarative import declarative_base')
    header.append('Base = declarative_base()' + sep + sep + sep)
    return sep.join(header)


def table_to_entity():
    with open('table.py', 'rb') as f:
        c = f.read()
        d = c.decode('utf-8')
    d = del_python_line_contact(d)
    header = create_header(d)
    tables = split_table(d)
    with open('entity.py', 'wb') as f:
        f.write(header.encode('utf-8'))
        for t in tables:
            tm = create_table_meta(t)
            e = create_entity_text(tm)
            c = e.encode('utf-8')
            f.write(c)
            f.write(b'\n\n\n')


if '__main__' == __name__:
    table_to_entity()
